<?xml version="1.0" encoding="UTF-8"?>
<!--Arbortext, Inc., 1988-2011, v.4002-->
<!DOCTYPE concept PUBLIC "-//IBM//DTD DITA IBM Concept//EN"
 "ibm-concept.dtd">
<?Pub Sty _display FontColor="red"?>
<concept id="lxoc_ibmcommon" xml:lang="en-us" rev="shv2">
<title><keyword conref="lxoc_conref.dita#lxoc_conref/ibm"/>-specific mechanisms</title>
<titlealts>
<navtitle><keyword conref="lxoc_conref.dita#lxoc_conref/ibm"/>-specific mechanisms for <keyword
conref="lxoc_conref.dita#lxoc_conref/ocrypto"/>
</navtitle>
<searchtitle><ph conref="lxcommon.dita#phrases/lib_title"/>: <keyword
conref="lxoc_conref.dita#lxoc_conref/ibm"/>-specific mechanisms for<keyword
conref="lxoc_conref.dita#lxoc_conref/ocrypto"/>
</searchtitle>
</titlealts>
<shortdesc>In your <keyword conref="lxoc_conref.dita#lxoc_conref/ocrypto"/> applications, you can
apply <keyword conref="lxoc_conref.dita#lxoc_conref/ibm"/>-specific mechanisms for special purposes
as offered by an exploited token. Information about which token or tokens support a given mechanism
is included in the description of each mechanism. </shortdesc>
<prolog>
<metadata>
<keywords>
<indexterm><keyword conref="lxoc_conref.dita#lxoc_conref/ibm"/>-specific mechanisms and features
<indexterm>common for <keyword conref="lxoc_conref.dita#lxoc_conref/ocrypto"
/></indexterm></indexterm>
<indexterm><keyword conref="lxoc_conref.dita#lxoc_conref/ocrypto"/>
<indexterm>common <keyword conref="lxoc_conref.dita#lxoc_conref/ibm"/>-specific mechanisms and
features </indexterm></indexterm>
</keywords>
</metadata>
</prolog>
<conbody>
<p/>
<table id="mechanism_reference"><title><keyword conref="lxoc_conref.dita#lxoc_conref/ibm"/>-specific
mechanisms</title><desc>
<p outputclass="summary">Reference table for the described IBM-specific mechanisms with two
columns.</p>
</desc><tgroup cols="2">
<colspec colname="col1" colwidth="7*"/>
<colspec colname="col2" colwidth="10*"/>
<thead>
<row>
<entry>Mechanism</entry>
<entry>Reference</entry>
</row>
</thead>
<tbody>
<row>
<entry>CKM_IBM_DILITHIUM</entry>
<entry><xref href="#lxoc_ibmcommon/CKM_IBM_DILITHIUM" format="dita"/></entry>
</row>
<row>
<entry>CKM_IBM_SHA3_224</entry>
<entry><xref href="#lxoc_ibmcommon/CKM_IBM_SHA3_nnn" format="dita"/></entry>
</row>
<row>
<entry>CKM_IBM_SHA3_256</entry>
<entry><xref href="#lxoc_ibmcommon/CKM_IBM_SHA3_nnn" format="dita"/></entry>
</row>
<row>
<entry>CKM_IBM_SHA3_384</entry>
<entry><xref href="#lxoc_ibmcommon/CKM_IBM_SHA3_nnn" format="dita"/></entry>
</row>
<row>
<entry>CKM_IBM_SHA3_512</entry>
<entry><xref href="#lxoc_ibmcommon/CKM_IBM_SHA3_nnn" format="dita"/></entry>
</row>
<row>
<entry>CKM_IBM_SHA3_224_HMAC</entry>
<entry><xref href="#lxoc_ibmcommon/CKM_IBM_SHA3_nnn_HMAC" format="dita"/></entry>
</row>
<row>
<entry>CKM_IBM_SHA3_256_HMAC</entry>
<entry><xref href="#lxoc_ibmcommon/CKM_IBM_SHA3_nnn_HMAC" format="dita"/></entry>
</row>
<row>
<entry>CKM_IBM_SHA3_384_HMAC</entry>
<entry><xref href="#lxoc_ibmcommon/CKM_IBM_SHA3_nnn_HMAC" format="dita"/></entry>
</row>
<row>
<entry>CKM_IBM_SHA3_512_HMAC</entry>
<entry><xref href="#lxoc_ibmcommon/CKM_IBM_SHA3_nnn_HMAC" format="dita"/></entry>
</row>
<row>
<entry>CKM_IBM_CMAC</entry>
<entry><xref href="#lxoc_ibmcommon/CKM_IBM_CMAC" format="dita"/></entry>
</row>
<row>
<entry>
<lines>CKM_IBM_EC_C448
(synonym: CKM_IBM_EC_X448)
</lines>
</entry>
<entry><xref href="#lxoc_ibmcommon/ecc_mechs" format="dita"/></entry>
</row>
<row>
<entry>
<lines>CKM_IBM_EC_C25519
(synonym: CKM_IBM_EC_X25519)
</lines>
</entry>
<entry><xref href="#lxoc_ibmcommon/ecc_mechs" format="dita"/></entry>
</row>
<row>
<entry>CKM_IBM_ED448_SHA3 </entry>
<entry><xref href="#lxoc_ibmcommon/ecc_mechs" format="dita"/></entry>
</row>
<row>
<entry>
<lines>CKM_IBM_ED25519_SHA512
(synonym: CKM_IBM_EDDSA_SHA512)
</lines>
</entry>
<entry><xref href="#lxoc_ibmcommon/ecc_mechs" format="dita"/></entry>
</row>
<row>
<entry>CKM_IBM_ATTRIBUTEBOUND_WRAP</entry>
<entry><xref href="#lxoc_ibmcommon/CKM_IBM_ATTRIBUTEBOUND_WRAP" format="dita"/></entry>
</row>
<!--
<row>
<entry>CKM_IBM_CPACF_WRAP</entry>
<entry><xref href="#lxoc_ibmcommon/ckm_ibm_cpacf_wrap" format="dita"/></entry>
</row>

<row>
<entry>CKM_IBM_BTC_DERIVE</entry>
<entry></entry>
</row>
<row>
<entry>CKM_IBM_ECDSA_OTHER</entry>
<entry></entry>
</row>
-->
</tbody>
</tgroup></table>
<!--<p>In addition, the following features are also described:</p>
<ul>
<li><xref href="lxoc_tok_ibm_feat1_reencrypt.dita"/></li>
<li>&lt;xref: SEC2035 openCryptoki:Bitcoin key derivation and Schnorr signatures  tbd></li>
<li>&lt;xref: SEC2036 openCryptoki: support crypto profiles  tbd></li>
<li>&lt;xref: SEC2041 openCryptoki: add crypto counters  tbd></li>
</ul>
*********** SEC2111 included, SEC2114 included **************************** 
-->
<section id="CKM_IBM_DILITHIUM">
<title>CKM_IBM_DILITHIUM</title>
<p><b>Availability:</b></p>
<p><!--SEC1818, SEC2015 -->The CKM_IBM_DILITHIUM mechanism is available with the <keyword
conref="lxoc_conref.dita#lxoc_conref/ep11token"/>.</p>
<p><b>Description:</b></p>
<p><term>Dilithium</term> is a post-quantum signature scheme. That is, it can generate signatures
that resist attacks from quantum computers, but also from classical computers.
<term>Dilithium</term> is one of the candidate algorithms submitted to the NIST post-quantum
cryptography project. At the time of writing, the NIST selection process was in round 2, so all keys
created with the CKM_IBM_DILITHIUM mechanism are internally flagged as <codeph>round2</codeph>. </p>
<p> Because Dilithium keys can only sign or verify, the <keyword
conref="lxoc_conref.dita#lxoc_conref/ep11token"/> only provides one single mechanism for all three
operations: key generation, sign, and verify. </p>
<p>With the <keyword conref="lxoc_conref.dita#lxoc_conref/ep11token"/>, you can also import and
export Dilithium keys by wrapping or unwrapping them using AES or TDES key encrypting keys (KEKs).
That is, you can protect <keyword conref="lxoc_conref.dita#lxoc_conref/dilith"/> keys that are sent
to another system, received from another system, or stored with data in a file. <ph rev="shv2">Use
any mechanism to wrap or unwrap <keyword conref="lxoc_conref.dita#lxoc_conref/ibm_dilith_keys"/>
that is convenient for your purposes, for example:</ph></p>
<ul compact="yes">
<li>CKM_AES_CBC_PAD</li>
<li>CKM_DES3_CBC_PAD</li>
</ul>
<p>On the <keyword conref="lxoc_conref.dita#lxoc_conref/atkews"/>, you must enable <keyword
conref="lxoc_conref.dita#lxoc_conref/dilith"/> processing by setting domain (access) control point
65 on the used <keyword conref="lxoc_conref.dita#lxoc_conref/cryptocoprocs"/> :</p>
<codeblock>65    XCP_CPB_ALG_PQC_DILITHIUM           enable support for <keyword conref="lxoc_conref.dita#lxoc_conref/dilith"/> algorithm</codeblock>
<p><b>Prerequisites</b>
<keyword conref="lxoc_conref.dita#lxoc_conref/ibm_dilith"/> has the following prerequisites:</p>
<ul>
<li><keyword conref="lxoc_conref.dita#lxoc_conref/ep11lib"/> 3.0 or later. <keyword
conref="lxoc_conref.dita#lxoc_conref/dilith"/> support in the <keyword
conref="lxoc_conref.dita#lxoc_conref/ep11hostlib"/> has oid = 1.3.6.1.4.1.2.267.1.6.5. </li>
<li>A Crypto Express7S feature or later, configured as <keyword
conref="lxoc_conref.dita#lxoc_conref/cexallplong"/> (CEX7P) with firmware level 4.7.15 or later </li>
</ul>
<p><b>Key type</b> The <keyword conref="lxoc_conref.dita#lxoc_conref/ibm"/>-specific key type for an
<keyword conref="lxoc_conref.dita#lxoc_conref/ibm_dilith_key"/> object is:<codeblock>
#define CKK_IBM_PQC_DILITHIUM (CKK_VENDOR_DEFINED +0x10023)</codeblock></p>
<p><b>Key form</b> The <keyword conref="lxoc_conref.dita#lxoc_conref/ep11hostlib"/> uses the
following key form for <keyword conref="lxoc_conref.dita#lxoc_conref/ibm_dilith"/> public and
private keys: </p>
<ul>
<li><b>Public key</b><codeblock>
DilithiumPublicKey ::= BIT STRING {
   SEQUENCE {
      rho BIT STRING, [2]  -- nonce
      t1 BIT STRING [3]    -- from vector(L)
   }
}</codeblock></li>
<li><b>Private key</b><codeblock>
DilithiumPrivateKey ::= SEQUENCE {
   version INTEGER,   -- v0, reserved 0
   rho BIT STRING,    -- nonce
   key BIT STRING,    -- key/seed/D
   tr BIT STRING,     -- PRF bytes (’CRH’ in spec)
   s1 BIT STRING,     -- vector(L)
   s2 BIT STRING,     -- vector(K)
   t0 BIT STRING,     -- low bits(vector L)
   t1 [0] IMPLICIT OPTIONAL {
      t1 BIT STRING,  -- high bits(vector L) 
                      -- see also public key
   }
}
</codeblock></li>
</ul>
<p><b>Attributes:</b></p>
<table id="lxoc_ibm_dilithium_attribs"><title>Attributes for <keyword
conref="lxoc_conref.dita#lxoc_conref/ibm_dilith_key"/></title><tgroup cols="3">
<colspec colname="col1" colwidth="14*"/>
<colspec colname="col2" colwidth="8*"/>
<colspec colname="col3" colwidth="16*"/>
<thead>
<row>
<entry>Attribute</entry>
<entry>Data type</entry>
<entry>Meaning</entry>
</row>
</thead>
<tbody>
<row>
<entry>CKA_IBM_DILITHIUM_KEYFORM</entry>
<entry>CK_ULONG</entry>
<entry>The Dilithium key form, currently only <term>round 2</term>.</entry>
</row>
<row>
<entry>CKA_IBM_DILITHIUM_RHO</entry>
<entry>CK_CHAR[32]</entry>
<entry>The private rho key component</entry>
</row>
<row>
<entry>CKA_IBM_DILITHIUM_SEED</entry>
<entry>CK_CHAR[32]</entry>
<entry>The private seed key component</entry>
</row>
<row>
<entry>CKA_IBM_DILITHIUM_TR</entry>
<entry>CK_CHAR[48]</entry>
<entry>The private tr key component</entry>
</row>
<row>
<entry>CKA_IBM_DILITHIUM_S1</entry>
<entry>CK_CHAR[480]</entry>
<entry>The private s1 key component</entry>
</row>
<row>
<entry>CKA_IBM_DILITHIUM_S2 </entry>
<entry>CK_CHAR[576]</entry>
<entry>The private s2 key component</entry>
</row>
<row>
<entry>CKA_IBM_DILITHIUM_T0 </entry>
<entry>CK_CHAR[2688]</entry>
<entry>The private t0 key component</entry>
</row>
<row>
<entry>CKA_IBM_DILITHIUM_T1</entry>
<entry>CK_CHAR[1728]</entry>
<entry>The public t1 key component</entry>
</row>
</tbody>
</tgroup></table>
<p rev="shv2">A Dilithium key also contains the usual standard attributes for public and private key
objects, such as CKA_CLASS, CKA_KEYTYPE. See tables <cite>Common Key Attributes</cite>,
<cite>Common Private Key Attributes</cite>, and <cite>Common Public Key Attributes</cite> in
<codeblock><xref href="https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/pkcs11-base-v3.0.html" format="html" scope="external">PKCS #11 Cryptographic Token Interface Base Specification Version 3.0</xref>.</codeblock></p>
<p>All created keys are internally flagged as <codeph>round2</codeph> keys via the
CKA_IBM_DILITHIUM_KEYFORM attribute. All attributes, except CKA_IBM_DILITHIUM_KEYFORM, are bit
strings. The CKA_IBM_DILITHIUM_KEYFORM attribute is a CK_ULONG, indicating the actual key form. The
currently only supported key form is:
<codeblock>#define IBM_DILITHIUM_KEYFORM_ROUND2                1</codeblock></p>
<p>
<keyword conref="lxoc_conref.dita#lxoc_conref/ibm_dilith"/> signatures have a length of 3366 bytes. </p>
<p><b>Functions for <keyword conref="lxoc_conref.dita#lxoc_conref/ibm_dilith_key"/> creation and
unwrapping: </b></p>
<p>Use function <apiname>C_GenerateKeyPair()</apiname> to create an <keyword
conref="lxoc_conref.dita#lxoc_conref/ibm_dilith_key"/> object consisting of a public/private key
pair. Note that the CKM_IBM_DILITHIUM mechanism has no mechanism-specific parameters. The following
is a sample for key object creation:</p>
<codeblock>
CK_BBOOL true = CK_TRUE;
CK_ATTRIBUTE public_template[] = {
    {CKA_VERIFY, &amp;true, sizeof(true)},
};
CK_ATTRIBUTE private_template[] = {
    {CKA_SIGN, &amp;true, sizeof(true)},
};

CK_MECHANISM mech;
CK_SESSION_HANDLE session;
CK_OBJECT_HANDLE publ_key = CK_INVALID_HANDLE, priv_key = CK_INVALID_HANDLE;
...
mech.mechanism = CKM_IBM_DILITHIUM;
mech.ulParameterLen = 0;
mech.pParameter = NULL;
CK_RV rv;

rv = C_GenerateKeyPair(session, &amp;mech,
                   public_template, 1,
                   private_template, 1,
                   &amp;publ_key, &amp;priv_key);
if (rv == CKR_OK) {
...
}


</codeblock>
<p>Use functions <apiname>C_WrapKey()</apiname> and <apiname>C_UnwrapKey()</apiname> if you need to
transport <keyword conref="lxoc_conref.dita#lxoc_conref/ibm_dilith_keys"/>. See the following sample
of an unwrapping operation:</p>
<codeblock>
CK_MECHANISM wrap_mech;
CK_OBJECT_HANDLE secret_key = CK_INVALID_HANDLE;
CK_BYTE_PTR wrapped_key = NULL;
CK_ULONG wrapped_keylen;
CK_OBJECT_HANDLE unwrapped_key = CK_INVALID_HANDLE;

CK_OBJECT_CLASS class = CKO_PRIVATE_KEY;
CK_KEY_TYPE key_type = CKK_IBM_PQC_DILITHIUM;
CK_OBJECT_HANDLE priv_key = CK_INVALID_HANDLE;
CK_BYTE unwrap_label[] = "unwrapped_private_Dilithium_Key";
CK_BBOOL true = TRUE;
CK_RV rv;

CK_ATTRIBUTE unwrap_tmpl[] = {
    {CKA_CLASS, &amp;class, sizeof(class)},
    {CKA_KEY_TYPE, &amp;key_type, sizeof(key_type)},
    {CKA_TOKEN, &amp;true, sizeof(true)},
    {CKA_LABEL, &amp;unwrap_label, sizeof(unwrap_label)},
    {CKA_SENSITIVE, &amp;true, sizeof(true)},
    {CKA_DECRYPT, &amp;true, sizeof(true)},
    {CKA_SIGN, &amp;true, sizeof(true)},
};

wrap_mech.mechanism = CKM_AES_CBC_PAD;
wrap_mech.pParameter = "0123456789abcdef";
wrap_mech.ulParameterLen = 16;

/* Generate wrapping key */
...

/* Wrap Dilithium key with wrapping key */
...

/* Unwrap Dilithium key */
rv = funcs->C_UnwrapKey(session, &amp;wrap_mech, secret_key,
                        wrapped_key, wrapped_keylen,
                        unwrap_tmpl,
                        sizeof(unwrap_tmpl) / sizeof(CK_ATTRIBUTE),
                        &amp;priv_key);
if (rv != CKR_OK) {
   ...
}
</codeblock>
<p><b>Restrictions for using <keyword conref="lxoc_conref.dita#lxoc_conref/ibm_dilith_keys"
/>:</b></p>
<ul>
<li><keyword conref="lxoc_conref.dita#lxoc_conref/ibm_dilith_keys"/> cannot actively be used to
transport (wrap and unwrap) other keys, but they can be wrapped and unwrapped for being transported
using standard key types (AES, TDES).</li>
<li><keyword conref="lxoc_conref.dita#lxoc_conref/ibm_dilith_keys"/> cannot be derived from given
keys. They can only be generated or imported from given key values.</li>
<li> Only <apiname>SignInit()</apiname> and <apiname>Sign()</apiname> (single-part operations) is
supported by the <keyword conref="lxoc_conref.dita#lxoc_conref/ep11hostlib"/>.
<apiname>SignUpdate()</apiname> and <apiname>SignFinal()</apiname> functions are not supported. The
same restrictions apply for verify operations accordingly.</li>
</ul>
</section>
<section id="CKM_IBM_SHA3_nnn">
<title>CKM_IBM_SHA3_nnn</title>
<p><b>Availability:</b></p>
<p><!--SEC1913-->The following SHA3 mechanisms are available for the <keyword
conref="lxoc_conref.dita#lxoc_conref/libicatoken"/>, the <keyword
conref="lxoc_conref.dita#lxoc_conref/ep11token"/>, and the <keyword
conref="lxoc_conref.dita#lxoc_conref/softtoken"/>:</p>
<ul>
<li>CKM_IBM_SHA3_224</li>
<li>CKM_IBM_SHA3_256</li>
<li>CKM_IBM_SHA3_384</li>
<li>CKM_IBM_SHA3_512</li>
</ul>
<p><b>Description:</b></p> <p>Use the listed mechanisms from the supporting tokens to perform the appropriate digest
operations using the secure hash algorithm SHA3, which is the latest version of the Secure Hash
Algorithm family as released by the <cite>National Institute of Standards and Technology
(NIST)</cite>. </p>
<table pgwide="0" id="sha3_nnn">
<tgroup cols="2">
<colspec colname="col1" colwidth="3*"></colspec>
<colspec colname="col2" colwidth="10*"></colspec>
<thead>
<row>
<entry>Mechanism</entry>
<entry>Flags and functions</entry>
</row>
</thead>
<tbody>
<row>
<entry><b>CKM_IBM_SHA3_224</b></entry>
<entry>The CKF_DIGEST flag is set to true for this mechanism.
Therefore, the function <apiname>C_DigestInit()</apiname> accepts the CKM_IBM_SHA3_224
mechanism.</entry>
</row>
<row>
<entry><b>CKM_IBM_SHA3_256</b></entry>
<entry>Same as for mechanism CKM_IBM_SHA3_224.</entry>
</row>
<row>
<entry><b>CKM_IBM_SHA3_384</b></entry>
<entry>Same as for mechanism CKM_IBM_SHA3_224.</entry>
</row>
<row>
<entry><b>CKM_IBM_SHA3_512</b></entry>
<entry>Same as for mechanism CKM_IBM_SHA3_224.</entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section id="CKM_IBM_SHA3_nnn_HMAC">
<title>CKM_IBM_SHA3_nnn_HMAC</title>
<p><b>Availability:</b></p>
<p><!--SEC1913-->The following SHA3 - HMAC mechanisms are available for the <keyword
conref="lxoc_conref.dita#lxoc_conref/libicatoken"/>, the <keyword
conref="lxoc_conref.dita#lxoc_conref/ep11token"/>, and the <keyword
conref="lxoc_conref.dita#lxoc_conref/softtoken"/>:</p>
<ul>
<li>CKM_IBM_SHA3_224_HMAC</li>
<li>CKM_IBM_SHA3_256_HMAC</li>
<li>CKM_IBM_SHA3_384_HMAC</li>
<li>CKM_IBM_SHA3_512_HMAC</li>
</ul>
<p><b>Description:</b></p>
<p>Use the listed mechanisms from the supporting tokens to perform hash-based message authentication
using the secure hash algorithm SHA3. The length of the HMAC output is according to the SHA3 hash
sizes:</p>
<ul compact="yes">
<li>CKM_IBM_SHA3_224_HMAC: 28 byte</li>
<li>CKM_IBM_SHA3_256_HMAC: 32 byte</li>
<li>CKM_IBM_SHA3_384_HMAC: 48 byte</li>
<li>CKM_IBM_SHA3_512_HMAC: 64 byte</li>
</ul>
<table pgwide="0" id="sha3_hmac">
<tgroup cols="2">
<colspec colname="col1" colwidth="9*"></colspec>
<colspec colname="col2" colwidth="20*"></colspec>
<thead>
<row>
<entry>Mechanism</entry>
<entry>Flags and functions</entry>
</row>
</thead>
<tbody>
<row>
<entry><b>CKM_IBM_SHA3_224_HMAC</b></entry>
<entry>The CKF_SIGN and CKF_VERIFY flags are set to true for this
mechanism. Therefore, the functions <apiname>C_SignInit()</apiname> and
<apiname>C_VerifyInit()</apiname> accept the CKM_IBM_CMAC mechanism.<p>Possible processing
sequences are:</p>
<ul>
<li>for single part sign or verify operations:<ul>
<li>C_SignInit() followed by C_Sign()</li>
<li>C_VerifyInit() followed by C_Verify()</li>
</ul></li>
<li>for multi-part sign or verify operations:<ul>
<li><apiname>C_SignInit()</apiname> followed by multiple <apiname>C_SignUpdate()</apiname>, then
followed by <apiname>C_SignFinal()</apiname></li>
<li><apiname>C_VerifyInit() </apiname>followed by multiple <apiname>C_VerifyUpdate()</apiname>, then
followed by <apiname>C_VerifyFinal()</apiname></li>
</ul></li>
</ul>
</entry>
</row>
<row>
<entry><b>CKM_IBM_SHA3_256_HMAC</b></entry>
<entry>Same as for mechanism CKM_IBM_SHA3_224_HMAC.</entry>
</row>
<row>
<entry><b>CKM_IBM_SHA3_384_HMAC</b></entry>
<entry>Same as for mechanism CKM_IBM_SHA3_224_HMAC.</entry>
</row>
<row>
<entry><b>CKM_IBM_SHA3_512_HMAC</b></entry>
<entry>Same as for mechanism CKM_IBM_SHA3_224_HMAC.</entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section id="CKM_IBM_CMAC">
<title>CKM_IBM_CMAC</title>
<p><b>Availability:</b></p>
<p><!--SEC1913-->The CKM_IBM_CMAC mechanism is available with the <keyword
conref="lxoc_conref.dita#lxoc_conref/ep11token"/>.</p>
<p><b>Description:</b></p>
<p>Use the CKM_IBM_CMAC mechanism to produce a block cipher-based message authentication code (CMAC)
to assure the authenticity and integrity of a message. You can use this mechanism with AES or TDES
keys (according to the <keyword conref="lxoc_conref.dita#lxoc_conref/pkcs11"/> mechanisms
CKM_AES_CMAC or CKM_DES3_CMAC).</p>
<p>The length of the output MAC is according to either the AES block size (16 bytes) or the TDES block size (8 bytes).
</p>
<p><b>Flags and functions:</b></p>
<p>The CKF_SIGN and CKF_VERIFY flags are set to true for this mechanism. Therefore, the functions
<apiname>C_SignInit()</apiname> and <apiname>C_VerifyInit()</apiname> accept the CKM_IBM_CMAC
mechanism.</p>
</section>
<section id="ecc_mechs">
<title>Mechanisms for Edwards Curves 25519 and 448 for ECDH and EdDSA</title>
<p><b>Availability:</b></p>
<p><!--SEC1919-->The following mechanisms for Edwards Curves 25519 and 448 for ECDH and EdDSA are
available with the <keyword conref="lxoc_conref.dita#lxoc_conref/ep11token"/>. </p>
<ul>
<li>CKM_IBM_EC_C448 (synonym: CKM_IBM_EC_X448)</li>
<li>CKM_IBM_EC_C25519 (synonym: CKM_IBM_EC_X25519)</li>
<li>CKM_IBM_ED448_SHA3</li>
<li>CKM_IBM_ED25519_SHA512 (synonym: CKM_IBM_EDDSA_SHA512)</li>
</ul>
<p><b>Description:</b></p>
<p>The CKM_IBM_EC_* mechanisms are used for key derivation with function
<apiname>C_DeriveKey()</apiname>, and use the CK_ECDH1_DERIVE_PARAMS structure (same as for the
CKM_ECDH1_DERIVE mechanism).</p>
<p>Mechanisms CKM_IBM_ED25519_SHA512 and CKM_IBM_ED448_SHA3 are used for sign/verify actions using
the functions <apiname>C_SignInit()/C_Sign()</apiname> and
<apiname>C_VerifyInit()/C_Verify()</apiname>. These mechanisms do not have a mechanism parameter. </p>
<p>Keys for use with these IBM-specific mechanisms are generated using mechanism CKM_EC_KEY_PAIR_GEN
with function <apiname>C_GenerateKeyPair()</apiname>, just like EC keys. Attribute CKA_EC_PARAMS
specifies the OID of the curves to generate keys for. Importing known clear key values works the
same as for EC keys. </p>
<p>No special key type is defined for keys for Edwards curves with above mechanisms. Key type CKK_EC
is also used for those keys. This is different to what is defined with the <keyword
conref="lxoc_conref.dita#lxoc_conref/pkcs11"/> version 3 standard, where additional key types are
defined for such keys (CKK_EC_EDWARDS and CKK_EC_MONTGOMERY). Also <keyword
conref="lxoc_conref.dita#lxoc_conref/pkcs11"/> version 3 defined new mechanisms for generating such
keys (CKM_EC_EDWARDS_KEY_PAIR_GEN and CKM_EC_MONTGOMERY_KEY_PAIR_GEN). Although different to
<keyword conref="lxoc_conref.dita#lxoc_conref/pkcs11"/> version 3, key type CKK_EC is used with
these IBM-specific mechanisms as long as <keyword conref="lxoc_conref.dita#lxoc_conref/ocrypto"/>
does not support the key types of <keyword conref="lxoc_conref.dita#lxoc_conref/pkcs11"/> version
3.</p>
<table pgwide="0">
<tgroup cols="2">
<colspec colname="col1" colwidth="12*"></colspec>
<colspec colname="col2" colwidth="26*"></colspec>
<thead>
<row>
<entry>Mechanism</entry>
<entry>Flags and functions</entry>
</row>
</thead>
<tbody>
<row>
<entry><b>CKM_IBM_EC_C448</b></entry>
<entry>
<ul>
<li>The CKF_DERIVE flag specifies that the mechanism can be used with
<apiname>C_DeriveKey()</apiname>.</li>
<li>The CKF_EC_F_P flag specifies that the mechanism can be used with EC domain parameters over the
finite field <i>F<sub>p</sub></i>.</li>
<li>The CKF_EC_UNCOMPRESS flag specifies that the mechanism can be used with elliptic curve point
uncompressed.</li>
<li>This mechanism can also use the CK_ECDH1_DERIVE_PARAMS structure.</li>
</ul>
</entry>
</row>
<row>
<entry><b>CKM_IBM_EC_C25519</b></entry>
<entry>Same as for mechanism CKM_IBM_EC_C448.</entry>
</row>
<row>
<entry><b>CKM_IBM_ED448_SHA3</b></entry>
<entry>The CKF_SIGN and CKF_VERIFY flags are set to true
for this mechanism. Therefore, the functions <apiname>C_SignInit()</apiname> and
<apiname>C_VerifyInit()</apiname> accept the CKM_IBM_ED448_SHA3 mechanism.
<ul>
<li>Possible processing sequences are the same as described with mechanism
CKM_IBM_SHA3_224_HMAC.</li>
<li>The CKF_EC_F_P flag specifies that the mechanism can be used with EC domain parameters over the
finite field <i>F<sub>p</sub></i>.</li>
<li>The CKF_EC_UNCOMPRESS flag specifies that the mechanism can be used with elliptic curve point
uncompressed.</li>
<li>This mechanism also must use the CK_ECDH1_DERIVE_PARAMS structure.</li>
</ul>
</entry>
</row>
<row>
<entry><b>CKM_IBM_ED25519_SHA512</b></entry>
<entry>Same as for mechanism CKM_IBM_ED448_SHA3.</entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section id="CKM_IBM_ATTRIBUTEBOUND_WRAP">
<title>CKM_IBM_ATTRIBUTEBOUND_WRAP</title>
<p><b>Availability:</b></p>
<p><!--SEC1905-->The CKM_IBM_ATTRIBUTEBOUND_WRAP mechanisms is available with the <keyword
conref="lxoc_conref.dita#lxoc_conref/ep11token"/>.</p>

<p><b>Description:</b></p>
<p>Keys may have attributes bound to them that control the usage of these key, for example,
restrictions on operations, like exportability. Attribute-bound keys provide a different format for
key wrapping and unwrapping,  where attributes cannot be separated from the key during transport and
thus must be contained in the wrapped format of the key. Therefore, you cannot use an
attribute-bound key to wrap a classical key or the other way round. For all operations except key
wrapping and unwrapping, attribute-bound keys behave exactly like regular keys. The
CKM_IBM_ATTRIBUTEBOUND_WRAP mechanism supports the wrapping of such attribute-bound keys.</p>
<p>As a prerequisite, you must specify attribute CKA_IBM_ATTRBOUND with value CK_TRUE when creating
a new key with bound attributes (default is CK_FALSE).</p>
<p>The goal of attribute-bound keys is to bind attributes to the key during transport via wrap and
unwrap. Additionally, the CKM_IBM_ATTRIBUTEBOUND_WRAP mechanism adds a signing/verification
processing to the wrapping/unwrapping actions. Part of the wrapped blob is signed and the signature
is appended to the blob. When unwrapping the transported key, the signature is verified. For both
actions, wrapping and unwrapping, the signing and verification key is propageted to the mechanism
using a parameter (see the description of the CK_IBM_ATTRIBUTEBOUND_WRAP parameter later in this
topic). To this end, you need both, a wrapping/unwrapping key pair and a signing/verification key
pair for the key transport. Therefore, to transport an attribute-bound key using asymmetric keys for
all involved operations, both sender and receiver create a key pair each, setting CKA_IBM_ATTRBOUND
to CK_TRUE for both the public and the private keys.</p>
<p>Thereafter, sender and receiver exchange the public keys via the usual public key transport and
then import this key using <apiname>C_CreateObject()</apiname>. Then, the sender applies wrapping
using the CKM_IBM_ATTRIBUTEBOUND_WRAP mechanism on the attribute-bound key and sends the resulting
blob to the receiver. The key is wrapped with the public key created by the receiver and signed by
the private key created by the sender. </p>

<p>The receiver can unwrap the blob with its own private key and verify the signature with the
public key created by the sender. Both, unwrapping and signature verification is done by the
attribute-bound unwrapping mechanism CKM_IBM_ATTRIBUTEBOUND_WRAP.</p>
<p>Only symmetric keys and RSA key(pairs) are supported as wrapping keys, also called key encrypting
keys (KEKs). The signing/verifying key can be a symmetric key, an RSA key, an EC key, or a DSA key. </p>

<p>Attribute-bound keys contain a number of Boolean attributes, controlling the usage and trust
inside the key blob. The attributes bound to the key are the following:</p>
<ul compact="yes">
<li>CKA_EXTRACTABLE</li>
<li>CKA_NEVER_EXTRACTABLE</li> 
<li>CKA_MODIFIABLE</li>
<li>CKA_SIGN</li>
<li>CKA_SIGN_RECOVER</li>
<li>CKA_DECRYPT</li>
<li>CKA_ENCRYPT</li>
<li>CKA_DERIVE</li>
<li>CKA_UNWRAP</li>
<li>CKA_WRAP</li>
<li>CKA_VERIFY</li>
<li>CKA_VERIFY_RECOVER</li>
<li>CKA_LOCAL</li>
<li>CKA_WRAP_WITH_TRUSTED</li>
<li>CKA_TRUSTED</li>
<li>CKA_IBM_NEVER_MODIFIABLE (unsupported by <keyword conref="lxoc_conref.dita#lxoc_conref/ocrypto"
/>)</li>
<li>CKA_IBM_RESTRICTABLE (unsupported by <keyword conref="lxoc_conref.dita#lxoc_conref/ocrypto"
/>)</li>
<li>CKA_IBM_ATTRBOUND</li>
<li>CKA_IBM_USE_AS_DATA</li>
<li>CKA_KEY_TYPE</li>
<li>CKA_VALUE_LEN</li>
</ul>
<p>Following key types are supported as attribute-bound keys:</p> 
<ul compact="yes">
<li>CKK_AES</li>
<li>CKK_DES2</li>
<li>CKK_DES3</li>
<li>CKK_GENERIC_SECRET</li>
<li>CKK_RSA</li>
<li>CKK_EC</li>
<li>CKK_DSA</li>
<li>CKK_DH</li>
<li>CKK_IBM_PQC_DILITHIUM</li>
</ul> 
<p>Attempts to create an attribute-bound key of an unsupported type returns
CKR_TEMPLATE_INCONSISTENT.</p>   
<p><b>Key and key-pair generation</b> You can specify the attribute CKA_IBM_ATTRBOUND only during
key creation (for key pairs in both templates, private and public). If the attribute is specified as
TRUE, the attribute CKA_SENSITIVE must be set to CK_TRUE in the attribute template for the public
key as well. This can be implicitly done by the <keyword
conref="lxoc_conref.dita#lxoc_conref/ep11token"/> configuration option
<codeph>FORCE_SENSITIVE</codeph>. If, however, the option has its default value CK_FALSE, key or key
pair generation fails with CKA_TEMPLATE_INCONSISTENT. Otherwise, attribute-bound keys behave exactly
like non-attribute-bound keys. </p>
<p><b>Key derivation</b> You can only use attribute-bound input keys to produce attribute-bound
derived keys. That is, if the input key is not attribute-bound, but the attribute CKA_IBM_ATTRBOUND
is set to CK_TRUE in the template for the derived key, derivation fails with return code
CKR_TEMPLATE_INCONSISTENT. </p>
<p>By default, a derived key inherits from the input key. That is, if CKA_IBM_ATTRBOUND is not
specified in the derivation template, it defaults to the value of the input key, or, if the input
key does not specify CKA_IBM_ATTRBOUND, it defaults to CK_FALSE. Thus, you can derive
attribute-bound keys from attribute-bound keys without specifying CKA_IBM_ATTRBOUND in the template
for the derived key. However, it is possible to derive classical <keyword
conref="lxoc_conref.dita#lxoc_conref/pkcs11"/> keys from attribute-bound keys. To do this, set the
attribute CKA_IBM_ATTRBOUND to FALSE in the template for the derived key. If CKA_IBM_ATTRBOUND is
specified when deriving asymmetric keys, it must be specified for both templates with the same
value. Otherwise, CKR_TEMPLATE_INCONSISTENT is returned.</p>
<p><b>Object creation</b> Attribute-bound public keys can be created with
<apiname>C_CreateObject()</apiname> by setting the CKA_IBM_ATTRBOUND attribute to TRUE.
Attribute-bound private keys or secret keys can only be generated with the following functions:</p>
<ul compact="yes">
<li><apiname>C_GenerateKey()</apiname></li>
<li><apiname>C_GenerateKeyPair()</apiname></li>
<li><apiname>C_DeriveKey()</apiname></li>
<li><apiname>C_UnwrapKey()</apiname></li>
</ul>
<p><apiname>C_CreateObject()</apiname> returns CKR_ATTRIBUTE_VALUE_INVALID on an attempt to create
attribute-bound private keys.</p>
<p><b>Object copy</b> When copying an object, the attribute CKA_IBM_ATTRBOUND cannot be changed. An attempt to change
it results in error CKA_ATTRIBUTE_READ_ONLY. </p>
<p><b>Attribute setting</b> Since some boolean attributes, mostly key usage attributes, are bound to
the key, the key blob changes when changing those attributes. This change is reflected in the value
of the CKA_IBM_OPAQUE attribute. The attribute CKA_IBM_ATTRBOUND is read-only and cannot be changed.
Attempts to change it returns error CKA_ATTRIBUTE_READ_ONLY. All other attributes follow standard
<keyword conref="lxoc_conref.dita#lxoc_conref/pkcs11"/> rules. However, attribute-bound keys must
have CKA_SENSITIVE set to CK_TRUE and thus have additional restrictions according to <keyword
conref="lxoc_conref.dita#lxoc_conref/pkcs11"/>.</p>
<p><b>How to use the  CKM_IBM_ATTRIBUTEBOUND_WRAP mechanism:</b></p>
<p>The mechanism requires a parameter of type CK_IBM_ATTRIBUTEBOUND_WRAP. </p>
<codeblock>
typedef struct CK_IBM_ATTRIBUTEBOUND_WRAP {
  CK_OBJECT_HANDLE hSignVerifyKey;
} CK_IBM_ATTRIBUTEBOUND_WRAP_PARAMS;</codeblock>
<p>This parameter provides the key for signing and verifying the wrapped key. </p>
<p>The CKM_IBM_ATTRIBUTEBOUND_WRAP mechanism has the following restrictions:</p>
<ul>
<li>All keys involved (target, wrapping/unwrapping, signature/verification) must be attribute-bound
keys (CKA_IBM_ATTRBOUND = CK_TRUE). Otherwise: <ul>
<li>For the target key on <apiname>C_WrapKey()</apiname>, CKR_KEY_NOT_WRAPPABLE is returned.</li>
<li>For the wrapping and unwrapping keys and the signature and verification keys,
CKR_KEY_FUNCTION_NOT_PERMITTED is returned.</li>
</ul></li>
<li>On <apiname>C_WrapKey()</apiname>, the signing private key must be capable of signing (CKA_SIGN
= CK_TRUE). Otherwise CKR_KEY_FUNCTION_NOT_PERMITTED is returned. </li>
<li>On <apiname>C_UnwrapKey()</apiname>, the verification public key must be capable of verifying
(CKA_VERIFY = CK_TRUE). Otherwise CKR_KEY_FUNCTION_NOT_PERMITTED is returned.</li>
</ul>
<p>Only RSA and symmetric keys are supported as wrapping keys. Usage of other key types returns
CKR_WRAPPING_KEY_TYPE_INCONSISTENT for wrapping, and CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT for
unwrapping.</p>
<p>Since the input blob to be unwrapped contains both the key and the attributes,
<apiname>C_UnwrapKey()</apiname> also recreates all attributes bound to the key, except the ones
flagged as not supported by <keyword conref="lxoc_conref.dita#lxoc_conref/ocrypto"/> (see the
previous list of attributes).</p>
<p> For unwrapping, CKA_KEY_TYPE must be specified in the unwrap template and must match the value
bound to the key. If the values do not match, unwrapping fails with CKR_TEMPLATE_INCONSISTENT. Any
key attribute of the wrapped key that is not specified in the unwrap template, is ignored. After a
successful unwrapping of the key and its attributes, the attributes are available via the standard
<keyword conref="lxoc_conref.dita#lxoc_conref/pkcs11"/> methods. Remember that attribute-bound keys
are sensitive keys and have additional restrictions on attribute visibility. </p>
<p><b>Flags and functions:</b></p>
<p>CKF_WRAP and CKF_UNWRAP flags are set to true for this mechanism. Therefore, the functions
<apiname>C_WrapKey()</apiname> and <apiname>C_UnwrapKey</apiname> accept the
CKM_IBM_ATTRIBUTEBOUND_WRAP mechanism.</p>
</section>
<!--SEC1915 PKEY_MODE: Mechanism  CKM_IBM_CPACF_WRAP   ************************************************
<section id="ckm_ibm_cpacf_wrap">
<title>CKM_IBM_CPACF_WRAP</title>
<p><b>Availability:</b></p>
<p>The CKM_IBM_CPACF_WRAP mechanism is available with the <keyword
conref="lxoc_conref.dita#lxoc_conref/ep11token"/> (see <xref href="lxoc_tok_ep11_conffile.dita"
/>.</p>
<p><b>Description:</b></p>
<p>A new option PKEY_MODE is available for the <keyword
conref="lxoc_conref.dita#lxoc_conref/ep11tokconfig"/>. With this option, you can define that
<keyword conref="lxoc_conref.dita#lxoc_conref/ep11"/> secure keys of type AES or EC are transformed
into protected keys, and the protected keys are used whenever possible. Protected keys support high
performance AES cryptography using the acceleration of the <keyword
conref="lxoc_conref.dita#lxoc_conref/cpacf"/> which is implemented in the IBM Z CPUs. Calls to
<keyword conref="lxoc_conref.dita#lxoc_conref/cpacf"/> are much faster than calls to an <keyword
conref="lxoc_conref.dita#lxoc_conref/ep11coproc"/>.</p>
<p>Protected keys are created from secure keys using mechanism CKM_IBM_CPACF_WRAP. This mechanism
was introduced with ep11 host library 3.0 and requires a CEX7P card. It also requires that the
secure key has boolean attribute CKA_IBM_PROTKEY_EXTRACTABLE=true.
Protected keys are created only from symmetric and private keys, not from public keys.</p>
<p><b>Flags and functions:</b></p>
<p/>
<p><b>Attributes:</b></p>
</section>
************************************************************************************ -->
<section id="misc_attribs_section">
<title>Miscellaneous attributes</title>
<p>This section list <keyword conref="lxoc_conref.dita#lxoc_conref/ibm"/>-specific attributes that
apply to objects but do not adhere to certain mechanisms or purposes.</p>
<dl>
<dlentry>
<dt>CKA_IBM_PROTKEY_NEVER_EXTRACTABLE</dt>
<dd>Marks objects that are never importable as protected key. Does conflict with
CKA_IBM_PROTKEY_EXTRACTABLE and behaves the same as CKA_NEVER_EXTRACTABLE.</dd>
</dlentry>
<dlentry>
<dt>CKA_IBM_STD_COMPLIANCE1</dt>
<dd>Compliance attribute. For <keyword conref="lxoc_conref.dita#lxoc_conref/ep11tokens"/> only
and for all types of <keyword conref="lxoc_conref.dita#lxoc_conref/ep11"/> keys. Compliance
settings correspond to standards-mandated sets of CPs. They are read-only, and are updated when CPs
are updated, or a domain changes state. See also <cite>Enterprise PKCS#11 (EP11) Library
structure</cite>.</dd>
</dlentry>
<dlentry>
<dt>CKA_IBM_PROTKEY_EXTRACTABLE</dt>
<dd>This key attribute is internally set to CK_TRUE, if the <keyword
conref="lxoc_conref.dita#lxoc_conref/ep11"/> configuration option PKEY_MODE is enabled and the key
has CKA_EXTRACTABLE set to FALSE. This makes the key eligible for being transformed into a protected
key for better performance, if applicable (see also <xref href="lxoc_tok_ep11_conffile.dita"/>).
</dd>
</dlentry>
<dlentry>
<dt>CKA_IBM_OPAQUE_PKEY</dt>
<dd>If the option PKEY_MODE is enabled in the <keyword
conref="lxoc_conref.dita#lxoc_conref/ep11tokconfig"/>, a protected key is generated for the
applicable key object and is added to the secure key object with this <keyword
conref="lxoc_conref.dita#lxoc_conref/ibm"/>-specific key attribute at first use of the key. A new
protected key is generated each time if required, for example, it an LPAR has been deactivated and
reactivated and its firmware master key has changed.</dd>
</dlentry>
<dlentry>
<dt>CKA_IBM_OPAQUE</dt>
<dd>Use this attribute for importing and exporting plain <keyword
conref="lxoc_conref.dita#lxoc_conref/cca"/> key objects into or from sensitive <keyword
conref="lxoc_conref.dita#lxoc_conref/ocrypto"/> key objects. See also <xref
href="lxoc_tok_cca_restrict.dita"/>.</dd>
</dlentry>
<dlentry>
<dt>CKA_IBM_USE_AS_DATA</dt>
<dd>Set this attribute  for keys where raw key bytes may be used as data of some cryptographic
operation, such as hashing (<apiname>DigestKey()</apiname>) or key derivation
(<apiname>DeriveKey()</apiname>). This restriction further controls key-based operations which do
not involve key migration, therefore, are not controlled by EXTRACTABLE or transport-related control
points.</dd>
</dlentry>
<!--<row>
<entry>CKA_IBM_RESTRICTABLE</entry>
<entry></entry>
</row>-->
<dlentry>
<dt>CKA_IBM_ATTRBOUND</dt>
<dd>Set this attribute for attribute-bound keys to enable these keys for being wrapped and
unwrapped using the CKM_IBM_ATTRIBUTEBOUND_WRAP mechanism.</dd>
</dlentry>
</dl>
</section>

</conbody>
</concept>
<?Pub *0000003393?>
